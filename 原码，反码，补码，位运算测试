        // 原码，反码，补码
        // 原码，将原数值转换成二进制，将最高位（第一个位置）视作符号位，0为正号，1为负号
        // +5的原码为   0000 0101
        // -5的原码为   1000 0101

        // 0和正数的反码和补码和原码一致

        // 反码，负数的反码，符号位1不变，其余位置取反
        // -5的原码为   1000 0101
        // -5的反码为   1111 1010

        // 补码，反码 + 0001，正常的二进制计算，满2进1，符号位也符合满2进1的原则，这就是补码的特殊性
        // -5的原码为   1000 0101
        // -5的反码为   1111 1010
        // -5的补码为   1111 1011
        // 特殊情况如下
        // 127的原码为  0111 1111
        // 127的反码为  1111 1111
        // 127的补码为  0000 0000   // +0001之后，全部满足满2进1，所以变成0000了，就连符号位也改变了


        System.out.println("位运算的简单计算");
        // 计算以下位运算的结果，位运算的计算方式，
        // 2 & 3
        // 2 | 3
        // 2 ^ 3
        // -2 ^ -3
        
        // 1.先转化成二进制原码，
        // 2.然后取补码，
        // 3.补码进行运算，
        // 4.计算结果还是补码，所以需要再转换成原码，
        // 6.然后再转换成十进制

        
        // 2的原码为 0010       补码为0010
        // 3的原码为 0011       补码为0011
        // 2 & 3    =>  0010 & 0011     // 转成二进制补码
        //          =>  0010            // 按位与运算，全为1则为1，否则为0。这里还是补码
        //          =>  0010            // 补码转成原码，正数容易转
        //          =>  2               // 转成十进制
        System.out.println("2 & 3的最终结果为：" + (2 & 3));      // 最终结果为2

        // 2 | 3    =>  0010 | 0011     //转成二进制的补码
        //          =>  0011            //按位或运算
        //          =>  0011            //转成原码
        //          =>  3               //转成十进制
        System.out.println("2|3的最终结果为：" + (2 | 3));        // 最终结果为3

        // 2 ^ 3    =>  0010 ^ 0011
        //          =>  0001
        //          =>  0001
        //          =>  1
        System.out.println("2^3的最终结果为：" + (2 ^ 3));        // 最终结果为1

        //-2    原码=>  1010    反码=>  1101    补码=>  1110
        //-3    原码=>  1011    反码=>  1100    补码=>  1101
        //-2 ^ -3   =>  1110 ^ 1101     //转二进制补码
        //          =>  0011            //按位异或运算
        //          =>  0011            //转成原码
        //          =>  3
        System.out.println("-2^-3的最终结果为：" + (-2 ^ -3));        // 最终结果为3
