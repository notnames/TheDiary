main方法{
定义map[][];
定义起点坐标x，y;
boolean b = 调用FindWay(map, x, y);
b == true    =》    则找到终点
b == false   =》    则没找到终点
}

布尔值方法 FindWay(int[][] map, int x, int y){
==if(终点坐标点map[6][5] == 2) { //这里主要是为递归服务，如果递归回来时，发现map已经找到终点了，则干掉整个方法
==//此时传入了一个坐标点，因为和设定的终点坐标点一致，所以跳出方法，返回游戏成功
==return-true；
==} else{//如果传入的坐标点不是终点坐标点，则进入else
====if（map[x][y]==0）{
======将这个坐标点0->2；
======//接下来是递归找路
======if(找路方法FindWay（map，x, y）) {return-true}，
======else-if(找路方法FindWay（map，x, y）) {return-true}，
======else-if(找路方法FindWay（map，x, y）) {return-true}，
======else-if(找路方法FindWay（map，x, y）) {return-true}，
======//如果发现上下左右都走不同，则在else里干掉这层方法，递归回去上一层方法
======else {把这个坐标点2->3，return-false}
====else{return-false}传入的这个坐标点不是0，所以不可能有从起点到终点的路径，游戏结束
==}
}

1，传入地图和坐标点（注意实参和形参的区别），if判断终点坐标点map[6][5]有没有被已走路径修改为2，如果为2，说明找到终点了，直接返回true，
2，否则判断传入的坐标点是不是0，如果不是0说明根本走不了，直接返回false，游戏结束
3，如果是0，先将这个点设置为2，然后判断这个坐标点的上下左右能不能走，如果上下左右走不通则将这个点设置为3，然后返回false；2->3
4，这个false会将这一层方法干掉，递归返回上一层方法；2->3
5，递归返回后，会从上一层方法上一次的顺序接下去执行，继续判断上下左右能不能走，如果发现走不通会继续干掉这个方法，递归回去更上一层；2->3
6，如果最后发现回到了起点，因为起点被设置为了2，所以会因为“2”，所以直接返回false，此时没有到达终点的路径
7，如果在上下左右找路时，arr[6][5]为终点，此时{map[6][4] == 0，0->2}=》在向右找路时=》此时map[6][5] == 0，=》向右递归，{map[6][5] == 0，0->2}在此时，找路传入的（map, x, y），发现此时地图的map[6][5] == 2，所以根据“1”，返回true，终结整个方法，说明找到最终路径
8，根据对引用类型变量所指向的数组内容进行修改，会直接影响到原数组对象。在方法递归时，map已经被修改过了，所以直接打印map能看见整个找路的痕迹。