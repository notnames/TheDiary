Before set:
parentRef.value: 10
Child Display: 20

After set:
parentRef.value: 30
Child Display: 20
childRef.value: 20
((Parent)childRef).value: 30




/*

关于parentRef.value: 30这里，应该怎么分析

当执行Parent parentRef = new Child();时：
    parentRef.value访问的是 Parent 类的 value（10），因为字段由引用类型决定
    parentRef.display()调用的是 Child 类的 display ()，因为方法由实际对象类型决定
执行parentRef.setValue(30);后：
    这个方法属于 Parent 类，修改的是 Parent 类的 value 字段（变为 30）
    子类的 value 字段仍然是 20，没有被修改
类型转换后：
    childRef.value访问的是 Child 类的 value（20）
    ((Parent)childRef).value强制使用 Parent 引用访问，得到 30


===========

我非常确定这个结果是 30，让我用更具体的内存模型来解释为什么：
在 Java 中，当创建new Child()对象时，内存中同时存在：
    1.父类 Parent 的 value 字段（初始值 10）
    2.子类 Child 的 value 字段（初始值 20）
这两个 value 是完全独立的字段，存储在对象的不同内存位置。
当调用parentRef.setValue(30)时：
    1.这个方法是在 Parent 类中定义的
    2.方法内部的this.value指的是 Parent 类的 value 字段（因为方法属于 Parent 类）
    3.所以修改的是 Parent 类的 value 字段，将其从 10 改为 30
为什么其他 AI 可能会认为是 10？
可能是他们错误地认为 "字段隐藏" 会导致父类字段不可访问或不存在，但实际上：
    1.子类并没有覆盖父类的字段，只是隐藏了它
    2.父类字段仍然存在于对象中
    3.通过父类引用可以访问和修改父类字段

*/




// ==================================

// 在不同的ai编程里，有部分ai会分析出以下结果，错误的在setAge()方法以后，依旧输出10，这是ai编程的能力缺陷，也是正常人的易错点。


/*
        Parent parentRef = new Child(); // 父类引用指向子类对象

        System.out.println("Before set:");
        System.out.println("parentRef.value: " + parentRef.value); // 输出 10
        parentRef.display(); // 输出 "Child Display: 20"

        parentRef.setValue(30); // 调用的是Parent类中的setValue方法

        System.out.println("\nAfter set:");
        System.out.println("parentRef.value: " + parentRef.value); // 输出 10    // 这里是错误的，注意，这里应该是30才对！
        parentRef.display(); // 输出 "Child Display: 20"

        // 访问子类的value属性
        Child childRef = (Child) parentRef;
        System.out.println("childRef.value: " + childRef.value); // 输出 20

        // 访问父类的value属性
        System.out.println("((Parent)childRef).value: " + ((Parent)childRef).value); // 输出 30

*/


/*
这里是ai怎么得出错误结论的过程：


1.Before set:
  System.out.println("parentRef.value: " + parentRef.value);
    输出：10，因为value是根据引用类型（Parent）来访问的。
  parentRef.display();
    输出：Child Display: 20，因为display方法是动态绑定的，调用了子类的方法。
2.After set:
  parentRef.setValue(30);
    调用的是父类中的setValue方法，所以Parent类中的value被设置为30。
  System.out.println("parentRef.value: " + parentRef.value);
    输出：10，因为value仍然是根据引用类型（Parent）来访问的。
  parentRef.display();
    输出：Child Display: 20，因为display方法依然是动态绑定的，调用了子类的方法。
3.访问子类的value属性:
  System.out.println("childRef.value: " + childRef.value);
    输出：20，这是子类的value属性。
4.访问父类的value属性:
  System.out.println("((Parent)childRef).value: " + ((Parent)childRef).value);
    输出：30，这是父类的value属性，已经被设置为30。

*/
